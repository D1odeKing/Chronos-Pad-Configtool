# Generated by KMK Configurator
import board
from kmk.kmk_keyboard import KMKKeyboard
from kmk.keys import KC
from kmk.scanners import DiodeOrientation
from kmk.modules.layers import Layers
from kmk.extensions.media_keys import MediaKeys
from kmk.modules.macros import Macros, Tap, Press, Release, Delay
from kmk.modules.encoder import EncoderHandler
from kmk.modules.analogin import AnalogInputs, AnalogInput
from kmk.extensions.peg_rgb_matrix import Rgb_matrix, Rgb_matrix_data

keyboard = KMKKeyboard()

# --- Extensions ---
keyboard.extensions.append(MediaKeys())

# --- Modules ---
keyboard.modules.append(Layers())
keyboard.modules.append(Macros())

# --- Hardware Settings ---
keyboard.diode_orientation = DiodeOrientation.COL2ROW
keyboard.col_pins = (board.GP0, board.GP1, board.GP2, board.GP3,)
keyboard.row_pins = (board.GP8, board.GP7, board.GP6, board.GP5, board.GP4,)

# Encoder configuration:
# --- Rotary Encoder Configuration ---
from kmk.modules.encoder import EncoderHandler

# Encoder configuration with layer cycling using KC.TO()
encoder_handler = EncoderHandler()
encoder_handler.pins = ((board.GP10, board.GP11, board.GP14, False),)

# Build encoder map for each layer
# Each layer's encoder: (CCW action, CW action, Button press action)
encoder_map = []
for i in range(2):
    next_layer = (i + 1) % 2
    prev_layer = (i - 1) % 2
    # CCW=prev layer, CW=next layer, Press=layer 0
    encoder_map.append(((KC.TO(prev_layer), KC.TO(next_layer), KC.TO(0)),))

encoder_handler.map = encoder_map
keyboard.modules.append(encoder_handler)

# Initialize layer cycler after keymap is defined
# NOTE: Add this line AFTER keyboard.keymap = [...] in your code.py:
# layer_cycler = LayerCycler(keyboard, num_layers=len(keyboard.keymap))

# AnalogIn configuration provided by user:
from analogio import AnalogIn as AnalogInPin
import time

# LED brightness control via 10k sliding potentiometer on GP28
class BrightnessSlider:
    def __init__(self, keyboard, pin, poll_interval=0.05):
        self.keyboard = keyboard
        self.analog_pin = AnalogInPin(pin)
        self.poll_interval = poll_interval
        self.last_poll = time.monotonic()
        self.threshold = 2000  # Minimum change to trigger brightness adjustment (out of 65535)
        
    def read_value(self):
        """Read analog value (0-65535)"""
        return self.analog_pin.value
    
    def during_bootup(self, keyboard):
        """Initialize at boot"""
        return
    
    def before_matrix_scan(self, keyboard):
        """Check slider position before each matrix scan"""
        return
    
    def after_matrix_scan(self, keyboard):
        """Check slider position after each matrix scan"""
        current_time = time.monotonic()
        
        # Only poll at specified interval to avoid excessive checking
        if current_time - self.last_poll < self.poll_interval:
            return
        
        self.last_poll = current_time
        current_value = self.read_value()
        
        # Convert 16-bit ADC value (0-65535) to brightness (0.0-1.0)
        # Using 0.3 as max to reduce current consumption
        target_brightness = (current_value / 65535.0) * 0.3
        
        # Check if keyboard has RGB extension
        if hasattr(keyboard, 'extensions'):
            for ext in keyboard.extensions:
                if hasattr(ext, 'set_brightness'):
                    ext.set_brightness(target_brightness)
                elif hasattr(ext, 'brightness'):
                    ext.brightness = target_brightness
                    if hasattr(ext, 'neopixel') and ext.neopixel:
                        ext.neopixel.brightness = target_brightness
        
        return
    
    def before_hid_send(self, keyboard):
        """Called before HID report is sent"""
        return
    
    def after_hid_send(self, keyboard):
        """Called after HID report is sent"""
        return
    
    def on_powersave_enable(self, keyboard):
        """Called when powersave is enabled"""
        return
    
    def on_powersave_disable(self, keyboard):
        """Called when powersave is disabled"""
        return

# Create and register brightness slider extension
brightness_slider = BrightnessSlider(keyboard, board.GP28, poll_interval=0.05)
keyboard.extensions.append(brightness_slider)


# Display configuration - Layer-aware keymap layout:
import board
import busio
import displayio
import terminalio
import adafruit_displayio_sh1106
from adafruit_display_text import label
from i2cdisplaybus import I2CDisplayBus

# I2C Display setup (SDA=GP20, SCL=GP21)
displayio.release_displays()
i2c = busio.I2C(scl=board.GP21, sda=board.GP20)
display_bus = I2CDisplayBus(i2c, device_address=0x3C)
display = adafruit_displayio_sh1106.SH1106(
    display_bus,
    width=128,
    height=64,
    rotation=180,  # Rotated 180 degrees
    colstart=2  # Column offset for proper alignment
)

# Create display group
splash = displayio.Group()
display.root_group = splash

# All layer keymaps - Generated from your configuration
all_layer_labels = [
    # Layer 0
    [
        ["Mute", "Vol+", "Vol-", "Bri+"],
        ["Up", "Down", "Left", "Rght"],
        ["LCtl", "LSft", "LAlt", "LGui"],
        ["E", "F", "G", "H"],
        ["TG(1)", "B", "C", "D"],
    ],
    # Layer 1
    [
        ["KP_MIN", "KP_AST", "KP_SLA", "NUMLOC"],
        ["KP_PLU", "KP_9", "KP_8", "KP_7"],
        ["KP_PLU", "KP_6", "KP_5", "KP_4"],
        ["KP_ENT", "KP_3", "KP_2", "KP_1"],
        ["TG(1)", "KP_DOT", "KP_0", "KP_0"],
    ],
]

# Helper function to update display with current layer
def update_display_for_layer(layer_index):
    """Update OLED display to show keymap for the specified layer."""
    global splash
    
    # Clear existing labels
    while len(splash) > 0:
        splash.pop()
    
    # Show layer indicator at top
    layer_label = label.Label(
        terminalio.FONT,
        text=f"Layer {layer_index}",
        color=0xFFFFFF,
        x=2,
        y=4
    )
    splash.append(layer_label)
    
    # Get labels for this layer
    if layer_index < len(all_layer_labels):
        key_labels = all_layer_labels[layer_index]
    else:
        key_labels = all_layer_labels[0]  # Fallback to layer 0
    
    # Display key layout (top row is physical top)
    for row_idx, row in enumerate(key_labels):
        for col_idx, key_text in enumerate(row):
            x_pos = (4 - 1 - col_idx) * 32 + 1
            y_pos = row_idx * 10 + 14
            text_area = label.Label(
                terminalio.FONT,
                text=key_text,
                color=0xFFFFFF,
                x=x_pos,
                y=y_pos
            )
            splash.append(text_area)

# Initial display - Show Layer 0
update_display_for_layer(0)
class LayerDisplaySync:
    """Keep the OLED layer view in sync with KMK state."""

    def __init__(self):
        self._last_layer = None

    def _active_layer(self, keyboard):
        try:
            layers = getattr(keyboard, "active_layers", None)
            if layers:
                return layers[0]
        except Exception:
            pass
        return 0

    def during_bootup(self, keyboard):
        self._last_layer = self._active_layer(keyboard)
        try:
            update_display_for_layer(self._last_layer)
        except Exception:
            pass

    def after_matrix_scan(self, keyboard):
        current = self._active_layer(keyboard)
        if current != self._last_layer:
            self._last_layer = current
            try:
                update_display_for_layer(current)
            except Exception:
                pass

layer_display_sync = LayerDisplaySync()
keyboard.modules.append(layer_display_sync)


# --- Macro Definitions ---
PASTE = KC.MACRO(Press(KC.LCTL), Tap(KC.V), Release(KC.LCTL))
COPY = KC.MACRO(Press(KC.LCTL), Tap(KC.C), Release(KC.LCTL))
STYLE1 = KC.MACRO(Press(KC.LCTL), Press(KC.LSFT), Press(KC.D), Press(KC.A), Release(KC.A), Release(KC.D), Release(KC.LSFT), Release(KC.LCTL))

# --- Keymap ---
keyboard.keymap = [
    # Layer 0
    [
        KC.TG(1), KC.B, KC.C, KC.D,
        KC.E, KC.F, KC.G, KC.H,
        KC.LCTL, KC.LSFT, KC.LALT, KC.LGUI,
        KC.UP, KC.DOWN, KC.LEFT, KC.RGHT,
        KC.MUTE, KC.VOLU, KC.VOLD, KC.BRIU,
    ],
    # Layer 1
    [
        KC.TG(1), KC.KP_DOT, KC.KP_0, KC.KP_0,
        KC.KP_ENTER, KC.KP_3, KC.KP_2, KC.KP_1,
        KC.KP_PLUS, KC.KP_6, KC.KP_5, KC.KP_4,
        KC.KP_PLUS, KC.KP_9, KC.KP_8, KC.KP_7,
        KC.KP_MINUS, KC.KP_ASTERISK, KC.KP_SLASH, KC.NUMLOCK,
    ],
]

# Peg RGB Matrix configuration
keyboard.rgb_pixel_pin = board.GP9
keyboard.num_pixels = 20
keyboard.brightness_limit = 0.5
keyboard.led_key_pos = list(range(20))  # Keys + underglow indices
rgb = Rgb_matrix(
    ledDisplay=[
                [252, 186, 211], [135, 206, 235], [135, 206, 235], [135, 206, 235], [135, 206, 235], [135, 206, 235], [135, 206, 235], [135, 206, 235],
                [152, 251, 152], [240, 230, 140], [255, 218, 185], [168, 230, 207], [255, 217, 61], [255, 217, 61], [255, 217, 61], [255, 217, 61],
                [243, 129, 129], [243, 129, 129], [243, 129, 129], [243, 129, 129]
            ],
    rgb_order=(1, 0, 2),
    disable_auto_write=True,
)
keyboard.extensions.append(rgb)
if __name__ == '__main__':
    keyboard.go()