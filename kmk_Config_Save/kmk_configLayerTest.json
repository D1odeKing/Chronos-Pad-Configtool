{
    "version": "2.0",
    "hardware": {
        "rows": 5,
        "cols": 4,
        "col_pins": [
            "board.GP0",
            "board.GP1",
            "board.GP2",
            "board.GP3"
        ],
        "row_pins": [
            "board.GP8",
            "board.GP7",
            "board.GP6",
            "board.GP5",
            "board.GP4"
        ],
        "diode_orientation": "COL2ROW"
    },
    "keymap": {
        "layers": [
            [
                [
                    "KC.NO",
                    "KC.NO",
                    "KC.NO",
                    "KC.NO"
                ],
                [
                    "KC.NO",
                    "KC.NO",
                    "KC.NO",
                    "KC.NO"
                ],
                [
                    "KC.NO",
                    "KC.NO",
                    "KC.NO",
                    "KC.NO"
                ],
                [
                    "KC.NO",
                    "KC.NO",
                    "KC.NO",
                    "KC.NO"
                ],
                [
                    "KC.TG(1)",
                    "KC.TG(2)",
                    "KC.TG(3)",
                    "KC.C"
                ]
            ],
            [
                [
                    "KC.NO",
                    "KC.NO",
                    "KC.NO",
                    "KC.NO"
                ],
                [
                    "KC.NO",
                    "KC.NO",
                    "KC.NO",
                    "KC.NO"
                ],
                [
                    "KC.NO",
                    "KC.NO",
                    "KC.NO",
                    "KC.NO"
                ],
                [
                    "KC.NO",
                    "KC.NO",
                    "KC.NO",
                    "KC.NO"
                ],
                [
                    "KC.TG(1)",
                    "KC.TG(2)",
                    "KC.TG(3)",
                    "KC.B"
                ]
            ],
            [
                [
                    "KC.NO",
                    "KC.NO",
                    "KC.NO",
                    "KC.NO"
                ],
                [
                    "KC.NO",
                    "KC.NO",
                    "KC.NO",
                    "KC.NO"
                ],
                [
                    "KC.NO",
                    "KC.NO",
                    "KC.NO",
                    "KC.NO"
                ],
                [
                    "KC.NO",
                    "KC.NO",
                    "KC.NO",
                    "KC.NO"
                ],
                [
                    "KC.TG(1)",
                    "KC.TG(2)",
                    "KC.TG(3)",
                    "KC.A"
                ]
            ]
        ],
        "current_layer": 0
    },
    "macros": {},
    "rgb": {
        "enabled": true,
        "config_str": "",
        "colors": {
            "0": {
                "0": "#FF0000",
                "1": "#FF0000",
                "2": "#FF0000",
                "3": "#FF0000",
                "4": "#FF0000",
                "5": "#FF0000",
                "6": "#FF0000",
                "7": "#FF0000",
                "8": "#FF0000",
                "9": "#FF0000",
                "10": "#FF0000",
                "11": "#FF0000",
                "12": "#FF0000",
                "13": "#FF0000",
                "14": "#FF0000",
                "15": "#FF0000",
                "16": "#FCBAD3",
                "17": "#FCBAD3",
                "18": "#FCBAD3",
                "19": "#87CEEB"
            },
            "1": {
                "0": "#aa55ff",
                "1": "#aa55ff",
                "2": "#aa55ff",
                "3": "#aa55ff",
                "4": "#aa55ff",
                "5": "#aa55ff",
                "6": "#aa55ff",
                "7": "#aa55ff",
                "8": "#aa55ff",
                "9": "#aa55ff",
                "10": "#aa55ff",
                "11": "#aa55ff",
                "12": "#aa55ff",
                "13": "#aa55ff",
                "14": "#aa55ff",
                "15": "#aa55ff",
                "16": "#FCBAD3",
                "17": "#FCBAD3",
                "18": "#FCBAD3",
                "19": "#87CEEB"
            },
            "2": {
                "0": "#aa5500",
                "1": "#aa5500",
                "2": "#aa5500",
                "3": "#aa5500",
                "4": "#aa5500",
                "5": "#aa5500",
                "6": "#aa5500",
                "7": "#aa5500",
                "8": "#aa5500",
                "9": "#aa5500",
                "10": "#aa5500",
                "11": "#aa5500",
                "12": "#aa5500",
                "13": "#aa5500",
                "14": "#aa5500",
                "15": "#aa5500",
                "16": "#FCBAD3",
                "17": "#FCBAD3",
                "18": "#FCBAD3",
                "19": "#87CEEB"
            }
        }
    },
    "extensions": {
        "encoder": {
            "enabled": true,
            "config_str": "# --- Rotary Encoder Configuration ---\nfrom kmk.modules.encoder import EncoderHandler\n\n# Custom layer cycling with display updates\nclass LayerCycler:\n    def __init__(self, keyboard, num_layers=3):\n        self.keyboard = keyboard\n        self.num_layers = num_layers\n        self.current_layer = 0\n        self.display_enabled = True\n\n    def next_layer(self):\n        # Deactivate current layer\n        if self.current_layer in self.keyboard.active_layers:\n            self.keyboard.active_layers.remove(self.current_layer)\n        # Move to next layer\n        self.current_layer = (self.current_layer + 1) % self.num_layers\n        print(f'Encoder: Next layer -> {self.current_layer}')\n        # Activate new layer\n        if self.current_layer not in self.keyboard.active_layers:\n            self.keyboard.active_layers.append(self.current_layer)\n        self.update_display()\n        return False\n\n    def prev_layer(self):\n        # Deactivate current layer\n        if self.current_layer in self.keyboard.active_layers:\n            self.keyboard.active_layers.remove(self.current_layer)\n        # Move to previous layer\n        self.current_layer = (self.current_layer - 1) % self.num_layers\n        print(f'Encoder: Prev layer -> {self.current_layer}')\n        # Activate new layer\n        if self.current_layer not in self.keyboard.active_layers:\n            self.keyboard.active_layers.append(self.current_layer)\n        self.update_display()\n        return False\n\n    def reset_layer(self):\n        # Clear all active layers\n        self.keyboard.active_layers.clear()\n        # Reset to layer 0\n        self.current_layer = 0\n        print(f'Encoder: Reset to layer 0')\n        self.keyboard.active_layers.append(0)\n        self.update_display()\n        return False\n\n    def update_display(self):\n        try:\n            # Call the global display update function\n            update_display_for_layer(self.current_layer)\n        except Exception as e:\n            print(f'Display update failed: {e}')\n\n# Create layer cycler\nlayer_cycler = None\n\n# Custom keycodes for layer cycling\nfrom kmk.keys import make_key\n\ndef _layer_next_handler(key, keyboard, *args, **kwargs):\n    if layer_cycler:\n        layer_cycler.next_layer()\n\ndef _layer_prev_handler(key, keyboard, *args, **kwargs):\n    if layer_cycler:\n        layer_cycler.prev_layer()\n\ndef _layer_reset_handler(key, keyboard, *args, **kwargs):\n    if layer_cycler:\n        layer_cycler.reset_layer()\n\n# Create custom layer keycodes\nLAYER_NEXT_KEY = make_key(names=('LAYER_NEXT',), on_press=_layer_next_handler)\nLAYER_PREV_KEY = make_key(names=('LAYER_PREV',), on_press=_layer_prev_handler)\nLAYER_RESET_KEY = make_key(names=('LAYER_RESET',), on_press=_layer_reset_handler)\n\n# Configure encoder\nencoder_handler = EncoderHandler()\nencoder_handler.pins = ((board.GP10, board.GP11, board.GP14, False),)\nencoder_handler.map = [(((LAYER_PREV_KEY, LAYER_NEXT_KEY, LAYER_RESET_KEY),),)]\nkeyboard.modules.append(encoder_handler)\n\n# Initialize layer cycler after keymap is defined\n# NOTE: Add this line AFTER keyboard.keymap = [...] in your code.py:\n# layer_cycler = LayerCycler(keyboard, num_layers=len(keyboard.keymap))"
        },
        "analogin": {
            "enabled": true,
            "config_str": "from analogio import AnalogIn as AnalogInPin\nimport time\n\n# Volume control via 10k sliding potentiometer on GP28\nclass VolumeSlider:\n    def __init__(self, keyboard, pin, poll_interval=0.05):\n        self.keyboard = keyboard\n        self.analog_pin = AnalogInPin(pin)\n        self.poll_interval = poll_interval\n        self.last_value = self.read_value()\n        self.last_poll = time.monotonic()\n        self.last_movement = time.monotonic()\n        self.threshold = 2000  # Minimum change to trigger volume adjustment (out of 65535)\n        self.step_size = 1  # Number of volume steps per change\n        self.idle_timeout = 2.0  # Seconds of no movement before requiring re-sync\n        self.synced = False  # Track if we've established direction after idle\n        \n    def read_value(self):\n        \"\"\"Read analog value (0-65535)\"\"\"\n        return self.analog_pin.value\n    \n    def during_bootup(self, keyboard):\n        \"\"\"Initialize at boot\"\"\"\n        self.last_value = self.read_value()\n        self.synced = False  # Require initial movement to establish baseline\n        return\n    \n    def before_matrix_scan(self, keyboard):\n        \"\"\"Check slider position before each matrix scan\"\"\"\n        return\n    \n    def after_matrix_scan(self, keyboard):\n        \"\"\"Check slider position after each matrix scan\"\"\"\n        current_time = time.monotonic()\n        \n        # Only poll at specified interval to avoid excessive checking\n        if current_time - self.last_poll < self.poll_interval:\n            return\n        \n        self.last_poll = current_time\n        current_value = self.read_value()\n        delta = current_value - self.last_value\n        \n        # Check if we've been idle too long (user may have adjusted volume elsewhere)\n        time_since_movement = current_time - self.last_movement\n        if time_since_movement > self.idle_timeout:\n            self.synced = False  # Need to re-sync on next movement\n        \n        # If slider moved significantly\n        if abs(delta) > self.threshold:\n            # If we're not synced (first movement after idle), just update position without sending\n            if not self.synced:\n                self.last_value = current_value\n                self.last_movement = current_time\n                self.synced = True\n                return\n            \n            # Normal operation: send volume commands based on direction\n            if delta > 0:\n                # Slider moved up (higher value) - increase volume\n                for _ in range(self.step_size):\n                    keyboard.hid_pending = True\n                    keyboard._send_hid()\n                    keyboard.add_key(KC.VOLU)\n                    keyboard._send_hid()\n                    keyboard.remove_key(KC.VOLU)\n                    keyboard._send_hid()\n            else:\n                # Slider moved down (lower value) - decrease volume\n                for _ in range(self.step_size):\n                    keyboard.hid_pending = True\n                    keyboard._send_hid()\n                    keyboard.add_key(KC.VOLD)\n                    keyboard._send_hid()\n                    keyboard.remove_key(KC.VOLD)\n                    keyboard._send_hid()\n            \n            self.last_value = current_value\n            self.last_movement = current_time\n    \n    def before_hid_send(self, keyboard):\n        \"\"\"Called before HID report is sent\"\"\"\n        return\n    \n    def after_hid_send(self, keyboard):\n        \"\"\"Called after HID report is sent\"\"\"\n        return\n    \n    def on_powersave_enable(self, keyboard):\n        \"\"\"Called when powersave is enabled\"\"\"\n        return\n    \n    def on_powersave_disable(self, keyboard):\n        \"\"\"Called when powersave is disabled\"\"\"\n        return\n\n# Create and register volume slider extension\nvolume_slider = VolumeSlider(keyboard, board.GP28, poll_interval=0.05)\nkeyboard.extensions.append(volume_slider)\n"
        },
        "display": {
            "enabled": false,
            "config_str": ""
        }
    }
}